// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
)

type TypeCategory string

const (
	TypeCategoryA TypeCategory = "A"
	TypeCategoryD TypeCategory = "D"
	TypeCategoryE TypeCategory = "E"
	TypeCategoryG TypeCategory = "G"
	TypeCategoryI TypeCategory = "I"
	TypeCategoryM TypeCategory = "M"
	TypeCategoryP TypeCategory = "P"
	TypeCategoryT TypeCategory = "T"
	TypeCategoryZ TypeCategory = "Z"
	TypeCategoryO TypeCategory = "O"
)

func (e TypeCategory) ToPointer() *TypeCategory {
	return &e
}

func (e *TypeCategory) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "A":
		fallthrough
	case "D":
		fallthrough
	case "E":
		fallthrough
	case "G":
		fallthrough
	case "I":
		fallthrough
	case "M":
		fallthrough
	case "P":
		fallthrough
	case "T":
		fallthrough
	case "Z":
		fallthrough
	case "O":
		*e = TypeCategory(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TypeCategory: %v", v)
	}
}

// FileInformation - basic information of the scanned file
type FileInformation struct {
	// The filename reported via `filename` header.
	DisplayName *string `json:"display_name,omitempty"`
	// Total file size in bytes.
	FileSize *int64 `json:"file_size,omitempty"`
	// The filetype using mimetype.
	FileType *string `json:"file_type,omitempty"`
	// The filetype in human readable format.
	FileTypeDescription *string `json:"file_type_description,omitempty"`
	// File's MD5 hash.
	Md5 *string `json:"md5,omitempty"`
	// The timestamp when upload progress started (first byte received) (in milliseconds)
	ReceiveDataTimestamp *string `json:"receive_data_timestamp,omitempty"`
	// File's SHA1 hash.
	Sha1 *string `json:"sha1,omitempty"`
	// File's SHA256 Hash.
	Sha256 *string `json:"sha256,omitempty"`
	// Digital signature information of the scanned file.
	//
	SignerInfos []SignerInfo `json:"signer_infos,omitempty"`
	// File type category.
	//   * `A` - Archive files
	//   * `AP` - Application
	//   * `D` - Document (Microsoft Office)
	//   * `D_ENC` - Encrypted Documents
	//   * `E` - Executables
	//   * `G` - Graphical format (JPG, PNG, GIF, etc.)
	//   * `I` - Disk image
	//   * `M` - Audio or video format
	//   * `OPENSSL_ENC` - OpenSSL Encrypted Files
	//   * `P` - PDF format
	//   * `T` - Text
	//   * `Z` - Mail messages
	//   * `O` - Other (anything that is not recognized as one of the above)
	//
	TypeCategory []TypeCategory `json:"type_category,omitempty"`
	// Total time elapsed for upload process (in milliseconds).
	UploadTime *int64 `json:"upload_time,omitempty"`
	// The timestamp when upload progress finished (all bytes received) (in milliseconds)
	UploadTimestamp *string `json:"upload_timestamp,omitempty"`
}

func (o *FileInformation) GetDisplayName() *string {
	if o == nil {
		return nil
	}
	return o.DisplayName
}

func (o *FileInformation) GetFileSize() *int64 {
	if o == nil {
		return nil
	}
	return o.FileSize
}

func (o *FileInformation) GetFileType() *string {
	if o == nil {
		return nil
	}
	return o.FileType
}

func (o *FileInformation) GetFileTypeDescription() *string {
	if o == nil {
		return nil
	}
	return o.FileTypeDescription
}

func (o *FileInformation) GetMd5() *string {
	if o == nil {
		return nil
	}
	return o.Md5
}

func (o *FileInformation) GetReceiveDataTimestamp() *string {
	if o == nil {
		return nil
	}
	return o.ReceiveDataTimestamp
}

func (o *FileInformation) GetSha1() *string {
	if o == nil {
		return nil
	}
	return o.Sha1
}

func (o *FileInformation) GetSha256() *string {
	if o == nil {
		return nil
	}
	return o.Sha256
}

func (o *FileInformation) GetSignerInfos() []SignerInfo {
	if o == nil {
		return nil
	}
	return o.SignerInfos
}

func (o *FileInformation) GetTypeCategory() []TypeCategory {
	if o == nil {
		return nil
	}
	return o.TypeCategory
}

func (o *FileInformation) GetUploadTime() *int64 {
	if o == nil {
		return nil
	}
	return o.UploadTime
}

func (o *FileInformation) GetUploadTimestamp() *string {
	if o == nil {
		return nil
	}
	return o.UploadTimestamp
}
