// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
)

type GroupIDs string

const (
	GroupIDsA GroupIDs = "A"
	GroupIDsD GroupIDs = "D"
	GroupIDsE GroupIDs = "E"
	GroupIDsG GroupIDs = "G"
	GroupIDsI GroupIDs = "I"
	GroupIDsM GroupIDs = "M"
	GroupIDsP GroupIDs = "P"
	GroupIDsT GroupIDs = "T"
	GroupIDsZ GroupIDs = "Z"
	GroupIDsO GroupIDs = "O"
)

func (e GroupIDs) ToPointer() *GroupIDs {
	return &e
}

func (e *GroupIDs) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "A":
		fallthrough
	case "D":
		fallthrough
	case "E":
		fallthrough
	case "G":
		fallthrough
	case "I":
		fallthrough
	case "M":
		fallthrough
	case "P":
		fallthrough
	case "T":
		fallthrough
	case "Z":
		fallthrough
	case "O":
		*e = GroupIDs(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GroupIDs: %v", v)
	}
}

type FileInfo struct {
	// File type description
	Description string `json:"description"`
	// File is password-protected or not
	Encrypted bool `json:"encrypted"`
	// File type extension
	Extensions string `json:"extensions"`
	// File type category
	GroupID string `json:"groupID"`
	// File type category.
	//   * `A` - Archive files
	//   * `AP` - Application
	//   * `D` - Document (Microsoft Office)
	//   * `D_ENC` - Encrypted Documents
	//   * `E` - Executables
	//   * `G` - Graphical format (JPG, PNG, GIF, etc.)
	//   * `I` - Disk image
	//   * `M` - Audio or video format
	//   * `OPENSSL_ENC` - OpenSSL Encrypted Files
	//   * `P` - PDF format
	//   * `T` - Text
	//   * `Z` - Mail messages
	//   * `O` - Other (anything that is not recognized as one of the above)
	//
	GroupIDs []GroupIDs `json:"groupIDs"`
	// MIME type
	Type string `json:"type"`
	// File type ID
	TypeID string `json:"typeID"`
	// A list of file type IDs
	TypeIds []string `json:"type_ids"`
}

func (o *FileInfo) GetDescription() string {
	if o == nil {
		return ""
	}
	return o.Description
}

func (o *FileInfo) GetEncrypted() bool {
	if o == nil {
		return false
	}
	return o.Encrypted
}

func (o *FileInfo) GetExtensions() string {
	if o == nil {
		return ""
	}
	return o.Extensions
}

func (o *FileInfo) GetGroupID() string {
	if o == nil {
		return ""
	}
	return o.GroupID
}

func (o *FileInfo) GetGroupIDs() []GroupIDs {
	if o == nil {
		return []GroupIDs{}
	}
	return o.GroupIDs
}

func (o *FileInfo) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

func (o *FileInfo) GetTypeID() string {
	if o == nil {
		return ""
	}
	return o.TypeID
}

func (o *FileInfo) GetTypeIds() []string {
	if o == nil {
		return []string{}
	}
	return o.TypeIds
}

// FileInfoDetails - Detailed information.
type FileInfoDetails struct {
}

// FileMetadata - Metadata information.
type FileMetadata struct {
}

// FileTypeResponse - response information from FileType engine
type FileTypeResponse struct {
	FileInfo FileInfo `json:"file_info"`
	// Detailed information.
	FileInfoDetails *FileInfoDetails `json:"file_info_details,omitempty"`
	// Metadata information.
	FileMetadata *FileMetadata `json:"file_metadata,omitempty"`
	// SHA256 Hash of user-interface template. For web console only.
	ResultTemplateHash *string `json:"result_template_hash,omitempty"`
}

func (o *FileTypeResponse) GetFileInfo() FileInfo {
	if o == nil {
		return FileInfo{}
	}
	return o.FileInfo
}

func (o *FileTypeResponse) GetFileInfoDetails() *FileInfoDetails {
	if o == nil {
		return nil
	}
	return o.FileInfoDetails
}

func (o *FileTypeResponse) GetFileMetadata() *FileMetadata {
	if o == nil {
		return nil
	}
	return o.FileMetadata
}

func (o *FileTypeResponse) GetResultTemplateHash() *string {
	if o == nil {
		return nil
	}
	return o.ResultTemplateHash
}
