// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"Metadefender/internal/sdk/pkg/models/shared"
	"Metadefender/internal/sdk/pkg/utils"
	"errors"
	"net/http"
)

type FileAnalysisSyncPostRequest struct {
	RequestBody []byte `request:"mediaType=application/octet-stream"`
	// Generated `session_id` from [Login](/mdcore/metadefender-core/ref#userlogin) call can be used as an `apikey` for API calls that require authentication.
	//
	Apikey *string `header:"style=simple,explode=false,name=apikey"`
	// password for archive ( URL encoded UTF-8 string)
	// Multiple passwords is also supported, format: archivepwd<X>
	//   * X: Could be empty
	//   * When having value, X must be a number >= 1
	//
	// For example:
	//   * archivepwd1: "fox"
	//   * archivepwd2: "cow"
	//   * archivepwd3: "bear"
	//
	Archivepwd *string `header:"style=simple,explode=false,name=archivepwd"`
	// Batch id to scan with, coming from `Initiate Batch` (If it is not given, it will be a single file scan.)
	Batch *string `header:"style=simple,explode=false,name=batch"`
	// Format: \<protocol://\>\<ip | domain\>:\<port\>\</path\>
	//
	// When this header is specified, users must not have body content in HTTP(S) request, otherwise expecting to hit 400 HTTP(S) error. Check response sample of HTTP 400 for details.
	//
	// Specify download link where MetaDefender Core could download the entire payload for processing.
	//   * Supported protocol: HTTP / HTTPS
	//   * Support both individual file scan (both webhook & non-webhook) and file processing in batch via link
	//   * Configurable setting under workflow rule (under "SCAN" tab):
	//     * Download timeout
	//     * Max file size to download
	//   * Support to return status of download progress back to client in HTTP(S) response
	//   * Pre-check supported to refuse downloading if the file size does not meet configured conditions, and/or MetaDefender Core's temp folder does not have sufficient disk space to save the downloaded file
	//
	// Limitation:
	//   * Redirect link is not supported
	//   * Retry to download is not supported
	//
	Downloadfrom *string `header:"style=simple,explode=false,name=downloadfrom"`
	// Since MetaDefender Core 5.0.0, preferred context / verbose information can be sent to the engines.
	//
	// Please see the below pages for the details:
	//   * [File Type engine](https://docs.opswat.com/mdcore/utilities-engines/supported-engines-metadata) (supported since Core 5.2.1)
	//   * [Archive engine](https://docs.opswat.com/mdcore/utilities-engines/supported-engines-metadata-header) (supported since Core 5.4.1)
	//   * [Deep CDR](https://docs.opswat.com/mdcore/deep-cdr/supported-engines-metadata-json)
	//   * [Proactive DLP](https://docs.opswat.com/mdcore/proactive-dlp/supported-engines-metadata-json)
	//
	EnginesMetadata *string `header:"style=simple,explode=false,name=engines-metadata"`
	// Specify name of file captured and displayed on corresponding MetaDefender Core scan result
	Filename *string `header:"style=simple,explode=false,name=filename"`
	// if local file scan is enabled the path to the file (see Security rule configuration)
	Filepath *string `header:"style=simple,explode=false,name=filepath"`
	// could be utilized for:
	//
	// Additional parameter for pre-defined post actions and external scanners
	// (as a part of STDIN input).
	//
	// Customized macro variable for watermarking text (Proactive DLP engine
	// feature).
	//
	// Additional context / verbose information for each file submission
	// (appended into JSON response scan result).
	//
	Metadata *string `header:"style=simple,explode=false,name=metadata"`
	// Select rule for the analysis, if no header given the default rule will be selected (URL encoded UTF-8 string of rule name)
	//
	Rule *string `header:"style=simple,explode=false,name=rule"`
	// user_agent header used to identify (and limit) access to a particular rule. For rule selection, `rule` header should be used.
	// Since MetaDefender Core 5.6.0, when user agent is matched the predefined setting in workflow rule,  the product will return X-Core-Id containing identity of MetaDefender Core server as a header of response.
	//
	UserAgent *string `header:"style=simple,explode=false,name=user_agent"`
	// name of the selected workflow (deprecated, use "rule" header parameter instead)
	Workflow *string `header:"style=simple,explode=false,name=workflow"`
}

func (o *FileAnalysisSyncPostRequest) GetRequestBody() []byte {
	if o == nil {
		return nil
	}
	return o.RequestBody
}

func (o *FileAnalysisSyncPostRequest) GetApikey() *string {
	if o == nil {
		return nil
	}
	return o.Apikey
}

func (o *FileAnalysisSyncPostRequest) GetArchivepwd() *string {
	if o == nil {
		return nil
	}
	return o.Archivepwd
}

func (o *FileAnalysisSyncPostRequest) GetBatch() *string {
	if o == nil {
		return nil
	}
	return o.Batch
}

func (o *FileAnalysisSyncPostRequest) GetDownloadfrom() *string {
	if o == nil {
		return nil
	}
	return o.Downloadfrom
}

func (o *FileAnalysisSyncPostRequest) GetEnginesMetadata() *string {
	if o == nil {
		return nil
	}
	return o.EnginesMetadata
}

func (o *FileAnalysisSyncPostRequest) GetFilename() *string {
	if o == nil {
		return nil
	}
	return o.Filename
}

func (o *FileAnalysisSyncPostRequest) GetFilepath() *string {
	if o == nil {
		return nil
	}
	return o.Filepath
}

func (o *FileAnalysisSyncPostRequest) GetMetadata() *string {
	if o == nil {
		return nil
	}
	return o.Metadata
}

func (o *FileAnalysisSyncPostRequest) GetRule() *string {
	if o == nil {
		return nil
	}
	return o.Rule
}

func (o *FileAnalysisSyncPostRequest) GetUserAgent() *string {
	if o == nil {
		return nil
	}
	return o.UserAgent
}

func (o *FileAnalysisSyncPostRequest) GetWorkflow() *string {
	if o == nil {
		return nil
	}
	return o.Workflow
}

// FileAnalysisSyncPost503ApplicationJSON - Server is too busy, scan queue is full. Try again later.
type FileAnalysisSyncPost503ApplicationJSON struct {
	Err *string `json:"err,omitempty"`
}

func (o *FileAnalysisSyncPost503ApplicationJSON) GetErr() *string {
	if o == nil {
		return nil
	}
	return o.Err
}

type FileAnalysisSyncPost500ApplicationJSONType string

const (
	FileAnalysisSyncPost500ApplicationJSONTypeLicenseExpired    FileAnalysisSyncPost500ApplicationJSONType = "LicenseExpired"
	FileAnalysisSyncPost500ApplicationJSONTypeNoAvailableRule   FileAnalysisSyncPost500ApplicationJSONType = "NoAvailableRule"
	FileAnalysisSyncPost500ApplicationJSONTypeInternalError     FileAnalysisSyncPost500ApplicationJSONType = "InternalError"
	FileAnalysisSyncPost500ApplicationJSONTypeLocalFileNotFound FileAnalysisSyncPost500ApplicationJSONType = "LocalFileNotFound"
	FileAnalysisSyncPost500ApplicationJSONTypeFileSizeExceeded  FileAnalysisSyncPost500ApplicationJSONType = "FileSizeExceeded"
)

type FileAnalysisSyncPost500ApplicationJSON struct {
	LicenseExpired    *shared.LicenseExpired
	NoAvailableRule   *shared.NoAvailableRule
	InternalError     *shared.InternalError
	LocalFileNotFound *shared.LocalFileNotFound
	FileSizeExceeded  *shared.FileSizeExceeded

	Type FileAnalysisSyncPost500ApplicationJSONType
}

func CreateFileAnalysisSyncPost500ApplicationJSONLicenseExpired(licenseExpired shared.LicenseExpired) FileAnalysisSyncPost500ApplicationJSON {
	typ := FileAnalysisSyncPost500ApplicationJSONTypeLicenseExpired

	return FileAnalysisSyncPost500ApplicationJSON{
		LicenseExpired: &licenseExpired,
		Type:           typ,
	}
}

func CreateFileAnalysisSyncPost500ApplicationJSONNoAvailableRule(noAvailableRule shared.NoAvailableRule) FileAnalysisSyncPost500ApplicationJSON {
	typ := FileAnalysisSyncPost500ApplicationJSONTypeNoAvailableRule

	return FileAnalysisSyncPost500ApplicationJSON{
		NoAvailableRule: &noAvailableRule,
		Type:            typ,
	}
}

func CreateFileAnalysisSyncPost500ApplicationJSONInternalError(internalError shared.InternalError) FileAnalysisSyncPost500ApplicationJSON {
	typ := FileAnalysisSyncPost500ApplicationJSONTypeInternalError

	return FileAnalysisSyncPost500ApplicationJSON{
		InternalError: &internalError,
		Type:          typ,
	}
}

func CreateFileAnalysisSyncPost500ApplicationJSONLocalFileNotFound(localFileNotFound shared.LocalFileNotFound) FileAnalysisSyncPost500ApplicationJSON {
	typ := FileAnalysisSyncPost500ApplicationJSONTypeLocalFileNotFound

	return FileAnalysisSyncPost500ApplicationJSON{
		LocalFileNotFound: &localFileNotFound,
		Type:              typ,
	}
}

func CreateFileAnalysisSyncPost500ApplicationJSONFileSizeExceeded(fileSizeExceeded shared.FileSizeExceeded) FileAnalysisSyncPost500ApplicationJSON {
	typ := FileAnalysisSyncPost500ApplicationJSONTypeFileSizeExceeded

	return FileAnalysisSyncPost500ApplicationJSON{
		FileSizeExceeded: &fileSizeExceeded,
		Type:             typ,
	}
}

func (u *FileAnalysisSyncPost500ApplicationJSON) UnmarshalJSON(data []byte) error {

	licenseExpired := new(shared.LicenseExpired)
	if err := utils.UnmarshalJSON(data, &licenseExpired, "", true, true); err == nil {
		u.LicenseExpired = licenseExpired
		u.Type = FileAnalysisSyncPost500ApplicationJSONTypeLicenseExpired
		return nil
	}

	noAvailableRule := new(shared.NoAvailableRule)
	if err := utils.UnmarshalJSON(data, &noAvailableRule, "", true, true); err == nil {
		u.NoAvailableRule = noAvailableRule
		u.Type = FileAnalysisSyncPost500ApplicationJSONTypeNoAvailableRule
		return nil
	}

	internalError := new(shared.InternalError)
	if err := utils.UnmarshalJSON(data, &internalError, "", true, true); err == nil {
		u.InternalError = internalError
		u.Type = FileAnalysisSyncPost500ApplicationJSONTypeInternalError
		return nil
	}

	localFileNotFound := new(shared.LocalFileNotFound)
	if err := utils.UnmarshalJSON(data, &localFileNotFound, "", true, true); err == nil {
		u.LocalFileNotFound = localFileNotFound
		u.Type = FileAnalysisSyncPost500ApplicationJSONTypeLocalFileNotFound
		return nil
	}

	fileSizeExceeded := new(shared.FileSizeExceeded)
	if err := utils.UnmarshalJSON(data, &fileSizeExceeded, "", true, true); err == nil {
		u.FileSizeExceeded = fileSizeExceeded
		u.Type = FileAnalysisSyncPost500ApplicationJSONTypeFileSizeExceeded
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u FileAnalysisSyncPost500ApplicationJSON) MarshalJSON() ([]byte, error) {
	if u.LicenseExpired != nil {
		return utils.MarshalJSON(u.LicenseExpired, "", true)
	}

	if u.NoAvailableRule != nil {
		return utils.MarshalJSON(u.NoAvailableRule, "", true)
	}

	if u.InternalError != nil {
		return utils.MarshalJSON(u.InternalError, "", true)
	}

	if u.LocalFileNotFound != nil {
		return utils.MarshalJSON(u.LocalFileNotFound, "", true)
	}

	if u.FileSizeExceeded != nil {
		return utils.MarshalJSON(u.FileSizeExceeded, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

// FileAnalysisSyncPost422ApplicationJSON - Body input is empty.
type FileAnalysisSyncPost422ApplicationJSON struct {
	Err *string `json:"err,omitempty"`
}

func (o *FileAnalysisSyncPost422ApplicationJSON) GetErr() *string {
	if o == nil {
		return nil
	}
	return o.Err
}

// FileAnalysisSyncPost411ApplicationJSON - Content-Length header is missing from the request.
type FileAnalysisSyncPost411ApplicationJSON struct {
	Err *string `json:"err,omitempty"`
}

func (o *FileAnalysisSyncPost411ApplicationJSON) GetErr() *string {
	if o == nil {
		return nil
	}
	return o.Err
}

// FileAnalysisSyncPost408ApplicationJSON - Timed out response. The scan is still in progress, but the connection is timed out.
type FileAnalysisSyncPost408ApplicationJSON struct {
	DataID *string `json:"data_id,omitempty"`
}

func (o *FileAnalysisSyncPost408ApplicationJSON) GetDataID() *string {
	if o == nil {
		return nil
	}
	return o.DataID
}

type FileAnalysisSyncPost400ApplicationJSONType string

const (
	FileAnalysisSyncPost400ApplicationJSONTypeInvalidAPIKeyGiven          FileAnalysisSyncPost400ApplicationJSONType = "InvalidAPIKeyGiven"
	FileAnalysisSyncPost400ApplicationJSONTypeBodyAndDownloadLinkGiven    FileAnalysisSyncPost400ApplicationJSONType = "BodyAndDownloadLinkGiven"
	FileAnalysisSyncPost400ApplicationJSONTypeInprogressBatchClosed       FileAnalysisSyncPost400ApplicationJSONType = "InprogressBatchClosed"
	FileAnalysisSyncPost400ApplicationJSONTypeBatchNotFound               FileAnalysisSyncPost400ApplicationJSONType = "BatchNotFound"
	FileAnalysisSyncPost400ApplicationJSONTypeBatchInstanceMismatched     FileAnalysisSyncPost400ApplicationJSONType = "BatchInstanceMismatched"
	FileAnalysisSyncPost400ApplicationJSONTypeBodyAndLocalFilePathGiven   FileAnalysisSyncPost400ApplicationJSONType = "BodyAndLocalFilePathGiven"
	FileAnalysisSyncPost400ApplicationJSONTypeFileUploadRejected          FileAnalysisSyncPost400ApplicationJSONType = "FileUploadRejected"
	FileAnalysisSyncPost400ApplicationJSONTypeRedirectLinkNotSupported    FileAnalysisSyncPost400ApplicationJSONType = "RedirectLinkNotSupported"
	FileAnalysisSyncPost400ApplicationJSONTypeInvalidDownloadLink         FileAnalysisSyncPost400ApplicationJSONType = "InvalidDownloadLink"
	FileAnalysisSyncPost400ApplicationJSONTypeInvalidProtocolDownloadLink FileAnalysisSyncPost400ApplicationJSONType = "InvalidProtocolDownloadLink"
)

type FileAnalysisSyncPost400ApplicationJSON struct {
	InvalidAPIKeyGiven          *shared.InvalidAPIKeyGiven
	BodyAndDownloadLinkGiven    *shared.BodyAndDownloadLinkGiven
	InprogressBatchClosed       *shared.InprogressBatchClosed
	BatchNotFound               *shared.BatchNotFound
	BatchInstanceMismatched     *shared.BatchInstanceMismatched
	BodyAndLocalFilePathGiven   *shared.BodyAndLocalFilePathGiven
	FileUploadRejected          *shared.FileUploadRejected
	RedirectLinkNotSupported    *shared.RedirectLinkNotSupported
	InvalidDownloadLink         *shared.InvalidDownloadLink
	InvalidProtocolDownloadLink *shared.InvalidProtocolDownloadLink

	Type FileAnalysisSyncPost400ApplicationJSONType
}

func CreateFileAnalysisSyncPost400ApplicationJSONInvalidAPIKeyGiven(invalidAPIKeyGiven shared.InvalidAPIKeyGiven) FileAnalysisSyncPost400ApplicationJSON {
	typ := FileAnalysisSyncPost400ApplicationJSONTypeInvalidAPIKeyGiven

	return FileAnalysisSyncPost400ApplicationJSON{
		InvalidAPIKeyGiven: &invalidAPIKeyGiven,
		Type:               typ,
	}
}

func CreateFileAnalysisSyncPost400ApplicationJSONBodyAndDownloadLinkGiven(bodyAndDownloadLinkGiven shared.BodyAndDownloadLinkGiven) FileAnalysisSyncPost400ApplicationJSON {
	typ := FileAnalysisSyncPost400ApplicationJSONTypeBodyAndDownloadLinkGiven

	return FileAnalysisSyncPost400ApplicationJSON{
		BodyAndDownloadLinkGiven: &bodyAndDownloadLinkGiven,
		Type:                     typ,
	}
}

func CreateFileAnalysisSyncPost400ApplicationJSONInprogressBatchClosed(inprogressBatchClosed shared.InprogressBatchClosed) FileAnalysisSyncPost400ApplicationJSON {
	typ := FileAnalysisSyncPost400ApplicationJSONTypeInprogressBatchClosed

	return FileAnalysisSyncPost400ApplicationJSON{
		InprogressBatchClosed: &inprogressBatchClosed,
		Type:                  typ,
	}
}

func CreateFileAnalysisSyncPost400ApplicationJSONBatchNotFound(batchNotFound shared.BatchNotFound) FileAnalysisSyncPost400ApplicationJSON {
	typ := FileAnalysisSyncPost400ApplicationJSONTypeBatchNotFound

	return FileAnalysisSyncPost400ApplicationJSON{
		BatchNotFound: &batchNotFound,
		Type:          typ,
	}
}

func CreateFileAnalysisSyncPost400ApplicationJSONBatchInstanceMismatched(batchInstanceMismatched shared.BatchInstanceMismatched) FileAnalysisSyncPost400ApplicationJSON {
	typ := FileAnalysisSyncPost400ApplicationJSONTypeBatchInstanceMismatched

	return FileAnalysisSyncPost400ApplicationJSON{
		BatchInstanceMismatched: &batchInstanceMismatched,
		Type:                    typ,
	}
}

func CreateFileAnalysisSyncPost400ApplicationJSONBodyAndLocalFilePathGiven(bodyAndLocalFilePathGiven shared.BodyAndLocalFilePathGiven) FileAnalysisSyncPost400ApplicationJSON {
	typ := FileAnalysisSyncPost400ApplicationJSONTypeBodyAndLocalFilePathGiven

	return FileAnalysisSyncPost400ApplicationJSON{
		BodyAndLocalFilePathGiven: &bodyAndLocalFilePathGiven,
		Type:                      typ,
	}
}

func CreateFileAnalysisSyncPost400ApplicationJSONFileUploadRejected(fileUploadRejected shared.FileUploadRejected) FileAnalysisSyncPost400ApplicationJSON {
	typ := FileAnalysisSyncPost400ApplicationJSONTypeFileUploadRejected

	return FileAnalysisSyncPost400ApplicationJSON{
		FileUploadRejected: &fileUploadRejected,
		Type:               typ,
	}
}

func CreateFileAnalysisSyncPost400ApplicationJSONRedirectLinkNotSupported(redirectLinkNotSupported shared.RedirectLinkNotSupported) FileAnalysisSyncPost400ApplicationJSON {
	typ := FileAnalysisSyncPost400ApplicationJSONTypeRedirectLinkNotSupported

	return FileAnalysisSyncPost400ApplicationJSON{
		RedirectLinkNotSupported: &redirectLinkNotSupported,
		Type:                     typ,
	}
}

func CreateFileAnalysisSyncPost400ApplicationJSONInvalidDownloadLink(invalidDownloadLink shared.InvalidDownloadLink) FileAnalysisSyncPost400ApplicationJSON {
	typ := FileAnalysisSyncPost400ApplicationJSONTypeInvalidDownloadLink

	return FileAnalysisSyncPost400ApplicationJSON{
		InvalidDownloadLink: &invalidDownloadLink,
		Type:                typ,
	}
}

func CreateFileAnalysisSyncPost400ApplicationJSONInvalidProtocolDownloadLink(invalidProtocolDownloadLink shared.InvalidProtocolDownloadLink) FileAnalysisSyncPost400ApplicationJSON {
	typ := FileAnalysisSyncPost400ApplicationJSONTypeInvalidProtocolDownloadLink

	return FileAnalysisSyncPost400ApplicationJSON{
		InvalidProtocolDownloadLink: &invalidProtocolDownloadLink,
		Type:                        typ,
	}
}

func (u *FileAnalysisSyncPost400ApplicationJSON) UnmarshalJSON(data []byte) error {

	invalidAPIKeyGiven := new(shared.InvalidAPIKeyGiven)
	if err := utils.UnmarshalJSON(data, &invalidAPIKeyGiven, "", true, true); err == nil {
		u.InvalidAPIKeyGiven = invalidAPIKeyGiven
		u.Type = FileAnalysisSyncPost400ApplicationJSONTypeInvalidAPIKeyGiven
		return nil
	}

	bodyAndDownloadLinkGiven := new(shared.BodyAndDownloadLinkGiven)
	if err := utils.UnmarshalJSON(data, &bodyAndDownloadLinkGiven, "", true, true); err == nil {
		u.BodyAndDownloadLinkGiven = bodyAndDownloadLinkGiven
		u.Type = FileAnalysisSyncPost400ApplicationJSONTypeBodyAndDownloadLinkGiven
		return nil
	}

	inprogressBatchClosed := new(shared.InprogressBatchClosed)
	if err := utils.UnmarshalJSON(data, &inprogressBatchClosed, "", true, true); err == nil {
		u.InprogressBatchClosed = inprogressBatchClosed
		u.Type = FileAnalysisSyncPost400ApplicationJSONTypeInprogressBatchClosed
		return nil
	}

	batchNotFound := new(shared.BatchNotFound)
	if err := utils.UnmarshalJSON(data, &batchNotFound, "", true, true); err == nil {
		u.BatchNotFound = batchNotFound
		u.Type = FileAnalysisSyncPost400ApplicationJSONTypeBatchNotFound
		return nil
	}

	batchInstanceMismatched := new(shared.BatchInstanceMismatched)
	if err := utils.UnmarshalJSON(data, &batchInstanceMismatched, "", true, true); err == nil {
		u.BatchInstanceMismatched = batchInstanceMismatched
		u.Type = FileAnalysisSyncPost400ApplicationJSONTypeBatchInstanceMismatched
		return nil
	}

	bodyAndLocalFilePathGiven := new(shared.BodyAndLocalFilePathGiven)
	if err := utils.UnmarshalJSON(data, &bodyAndLocalFilePathGiven, "", true, true); err == nil {
		u.BodyAndLocalFilePathGiven = bodyAndLocalFilePathGiven
		u.Type = FileAnalysisSyncPost400ApplicationJSONTypeBodyAndLocalFilePathGiven
		return nil
	}

	fileUploadRejected := new(shared.FileUploadRejected)
	if err := utils.UnmarshalJSON(data, &fileUploadRejected, "", true, true); err == nil {
		u.FileUploadRejected = fileUploadRejected
		u.Type = FileAnalysisSyncPost400ApplicationJSONTypeFileUploadRejected
		return nil
	}

	redirectLinkNotSupported := new(shared.RedirectLinkNotSupported)
	if err := utils.UnmarshalJSON(data, &redirectLinkNotSupported, "", true, true); err == nil {
		u.RedirectLinkNotSupported = redirectLinkNotSupported
		u.Type = FileAnalysisSyncPost400ApplicationJSONTypeRedirectLinkNotSupported
		return nil
	}

	invalidDownloadLink := new(shared.InvalidDownloadLink)
	if err := utils.UnmarshalJSON(data, &invalidDownloadLink, "", true, true); err == nil {
		u.InvalidDownloadLink = invalidDownloadLink
		u.Type = FileAnalysisSyncPost400ApplicationJSONTypeInvalidDownloadLink
		return nil
	}

	invalidProtocolDownloadLink := new(shared.InvalidProtocolDownloadLink)
	if err := utils.UnmarshalJSON(data, &invalidProtocolDownloadLink, "", true, true); err == nil {
		u.InvalidProtocolDownloadLink = invalidProtocolDownloadLink
		u.Type = FileAnalysisSyncPost400ApplicationJSONTypeInvalidProtocolDownloadLink
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u FileAnalysisSyncPost400ApplicationJSON) MarshalJSON() ([]byte, error) {
	if u.InvalidAPIKeyGiven != nil {
		return utils.MarshalJSON(u.InvalidAPIKeyGiven, "", true)
	}

	if u.BodyAndDownloadLinkGiven != nil {
		return utils.MarshalJSON(u.BodyAndDownloadLinkGiven, "", true)
	}

	if u.InprogressBatchClosed != nil {
		return utils.MarshalJSON(u.InprogressBatchClosed, "", true)
	}

	if u.BatchNotFound != nil {
		return utils.MarshalJSON(u.BatchNotFound, "", true)
	}

	if u.BatchInstanceMismatched != nil {
		return utils.MarshalJSON(u.BatchInstanceMismatched, "", true)
	}

	if u.BodyAndLocalFilePathGiven != nil {
		return utils.MarshalJSON(u.BodyAndLocalFilePathGiven, "", true)
	}

	if u.FileUploadRejected != nil {
		return utils.MarshalJSON(u.FileUploadRejected, "", true)
	}

	if u.RedirectLinkNotSupported != nil {
		return utils.MarshalJSON(u.RedirectLinkNotSupported, "", true)
	}

	if u.InvalidDownloadLink != nil {
		return utils.MarshalJSON(u.InvalidDownloadLink, "", true)
	}

	if u.InvalidProtocolDownloadLink != nil {
		return utils.MarshalJSON(u.InvalidProtocolDownloadLink, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type FileAnalysisSyncPostResponse struct {
	// The scan is completed before the connection timeout occurs
	AnalysisResult *shared.AnalysisResult
	// Callback URL is not supported.
	CallbackURLNotSupported *shared.CallbackURLNotSupported
	// HTTP response content type for this operation
	ContentType string
	// HTTP response status code for this operation
	StatusCode int
	// Raw HTTP response; suitable for custom response parsing
	RawResponse *http.Response
	// API key is invalid.
	FileAnalysisSyncPost400ApplicationJSONOneOf *FileAnalysisSyncPost400ApplicationJSON
	// Timed out response. The scan is still in progress, but the connection is timed out.
	FileAnalysisSyncPost408ApplicationJSONObject *FileAnalysisSyncPost408ApplicationJSON
	// Content-Length header is missing from the request.
	FileAnalysisSyncPost411ApplicationJSONObject *FileAnalysisSyncPost411ApplicationJSON
	// Body input is empty.
	FileAnalysisSyncPost422ApplicationJSONObject *FileAnalysisSyncPost422ApplicationJSON
	// Internal Server Error.
	FileAnalysisSyncPost500ApplicationJSONOneOf *FileAnalysisSyncPost500ApplicationJSON
	// Server is too busy, scan queue is full. Try again later.
	FileAnalysisSyncPost503ApplicationJSONObject *FileAnalysisSyncPost503ApplicationJSON
}

func (o *FileAnalysisSyncPostResponse) GetAnalysisResult() *shared.AnalysisResult {
	if o == nil {
		return nil
	}
	return o.AnalysisResult
}

func (o *FileAnalysisSyncPostResponse) GetCallbackURLNotSupported() *shared.CallbackURLNotSupported {
	if o == nil {
		return nil
	}
	return o.CallbackURLNotSupported
}

func (o *FileAnalysisSyncPostResponse) GetContentType() string {
	if o == nil {
		return ""
	}
	return o.ContentType
}

func (o *FileAnalysisSyncPostResponse) GetStatusCode() int {
	if o == nil {
		return 0
	}
	return o.StatusCode
}

func (o *FileAnalysisSyncPostResponse) GetRawResponse() *http.Response {
	if o == nil {
		return nil
	}
	return o.RawResponse
}

func (o *FileAnalysisSyncPostResponse) GetFileAnalysisSyncPost400ApplicationJSONOneOf() *FileAnalysisSyncPost400ApplicationJSON {
	if o == nil {
		return nil
	}
	return o.FileAnalysisSyncPost400ApplicationJSONOneOf
}

func (o *FileAnalysisSyncPostResponse) GetFileAnalysisSyncPost408ApplicationJSONObject() *FileAnalysisSyncPost408ApplicationJSON {
	if o == nil {
		return nil
	}
	return o.FileAnalysisSyncPost408ApplicationJSONObject
}

func (o *FileAnalysisSyncPostResponse) GetFileAnalysisSyncPost411ApplicationJSONObject() *FileAnalysisSyncPost411ApplicationJSON {
	if o == nil {
		return nil
	}
	return o.FileAnalysisSyncPost411ApplicationJSONObject
}

func (o *FileAnalysisSyncPostResponse) GetFileAnalysisSyncPost422ApplicationJSONObject() *FileAnalysisSyncPost422ApplicationJSON {
	if o == nil {
		return nil
	}
	return o.FileAnalysisSyncPost422ApplicationJSONObject
}

func (o *FileAnalysisSyncPostResponse) GetFileAnalysisSyncPost500ApplicationJSONOneOf() *FileAnalysisSyncPost500ApplicationJSON {
	if o == nil {
		return nil
	}
	return o.FileAnalysisSyncPost500ApplicationJSONOneOf
}

func (o *FileAnalysisSyncPostResponse) GetFileAnalysisSyncPost503ApplicationJSONObject() *FileAnalysisSyncPost503ApplicationJSON {
	if o == nil {
		return nil
	}
	return o.FileAnalysisSyncPost503ApplicationJSONObject
}
