// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"Metadefender/internal/sdk/pkg/models/shared"
	"bytes"
	"encoding/json"
	"errors"
	"net/http"
)

type FileAnalysisPostRequest struct {
	RequestBody []byte `request:"mediaType=application/octet-stream"`
	// Generated `session_id` from [Login](/mdcore/metadefender-core/ref#userlogin) call can be used as an `apikey` for API calls that require authentication.
	//
	Apikey *string `header:"style=simple,explode=false,name=apikey"`
	// password for archive ( URL encoded UTF-8 string)
	// Multiple passwords is also supported, format: archivepwdX
	//   * X: Could be empty
	//   * When having value, X must be a number >= 1
	//
	// For example:
	//   * archivepwd1: "fox"
	//   * archivepwd2: "cow"
	//   * archivepwd3: "bear"
	//
	Archivepwd *string `header:"style=simple,explode=false,name=archivepwd"`
	// Batch id to scan with, coming from `Initiate Batch` (If it is not given, it will be a single file scan.)
	Batch *string `header:"style=simple,explode=false,name=batch"`
	// Client's URL where MetaDefender Core will notify scan result back to
	// whenever scan is finished (webhooks model).
	//   * Format: \<protocol://\>\<ip | domain\>:\<port\>\</path\>
	//     * Example: http://10.0.1.100:8081/listenback
	//   * Supported protocol: HTTP / HTTPS
	//   * Method: POST
	//
	Callbackurl *string `header:"style=simple,explode=false,name=callbackurl"`
	// Format: \<protocol://\>\<ip | domain\>:\<port\>\</path\>
	//
	// Since MetaDefender Core 4.19.1, the product started supporting users to process file by just specifying a direct download link.
	//
	// When this header is specified, users must not have body content in HTTP(S) request, otherwise expecting to hit 400 HTTP(S) error. Check response sample of HTTP 400 for details.
	//
	// Specify download link where MetaDefender Core could download the entire payload for processing.
	//   * Supported protocol: HTTP / HTTPS
	//   * Support both
	//     * Individual file scan (both webhook & non-webhook)
	//     * File processing in batch via link
	//       * Simply use `downloadfrom` header for each file scan request in a batch, no further requirement on batch request itself to utilize scan via link feature.
	//       * `Note`: Cancelling a batch will result in auto cancelling all registered individual scan requests which are still in downloading status
	//   * Configurable setting under workflow rule (under "SCAN" tab):
	//     * Download timeout
	//     * Max file size to download
	//   * Support to return status of download progress back to client in HTTP(S) response
	//   * Pre-check supported to refuse downloading if the file size does not meet configured conditions, and/or MetaDefender Core's temp folder does not have sufficient disk space to save the downloaded file
	//
	// Limitation:
	//   * Redirect link is not supported
	//   * Retry to download is not supported
	//
	Downloadfrom *string `header:"style=simple,explode=false,name=downloadfrom"`
	// Since MetaDefender Core 5.0.0, preferred context / verbose information can be sent to the engines.
	//
	// Please see the below pages for the details:
	//   * [File Type engine](https://docs.opswat.com/mdcore/utilities-engines/supported-engines-metadata) (supported since Core 5.2.1)
	//   * [Archive engine](https://docs.opswat.com/mdcore/utilities-engines/supported-engines-metadata-header) (supported since Core 5.4.1)
	//   * [Deep CDR](https://docs.opswat.com/mdcore/deep-cdr/supported-engines-metadata-json)
	//   * [Proactive DLP](https://docs.opswat.com/mdcore/proactive-dlp/supported-engines-metadata-json)
	//
	EnginesMetadata *string `header:"style=simple,explode=false,name=engines-metadata"`
	// The name of the submitted file
	Filename *string `header:"style=simple,explode=false,name=filename"`
	// if local file scan is enabled the path to the file (see Security rule configuration)
	Filepath *string `header:"style=simple,explode=false,name=filepath"`
	// This custom global timeout (in seconds) will override the global timeout predefined in corresponding workflow rule.
	//
	GlobalTimeout *int64 `header:"style=simple,explode=false,name=global-timeout"`
	// could be utilized for:
	//
	// Additional parameter for pre-defined post actions and external scanners
	// (as a part of STDIN input).
	//
	// Customized macro variable for watermarking text (Proactive DLP engine
	// feature).
	//
	// Additional context / verbose information for each file submission
	// (appended into JSON response scan result).
	//
	Metadata *string `header:"style=simple,explode=false,name=metadata"`
	// Select rule for the analysis, if no header given the default rule will be selected (URL encoded UTF-8 string of rule name)
	//
	Rule *string `header:"style=simple,explode=false,name=rule"`
	// Client's URL where MetaDefender Core will send the sanitized file as the body of a POST request back to
	// whenever scan is finished (webhooks model).
	//   * Format: \<protocol://\>\<ip | domain\>:\<port\>\</path\>
	//     * Example: http://10.0.1.100:8081/listensanitizedfile
	//   * Supported protocol: HTTP / HTTPS
	//   * Method: POST
	//   * Mandatory headers:
	//     * `user-agent`: "OPSWAT MetaDefender Core V4"
	//     * `dataid`: "<data id of original file submission>"
	//     * `sanitization-result`: "Sanitized Successfully" or "Sanitized Partially" or "Sanitized File Removed"
	//     * `sanitized-file-hash`: "<SHA256 hash value of sanitized file>"
	//     * `Content-Disposition`: attachment; filename="<name of sanitized file>"
	//     * `Content-Length`: <actual size of sanitized file>
	//
	Sanitizedurl *string `header:"style=simple,explode=false,name=sanitizedurl"`
	// user_agent header used to identify (and limit) access to a particular rule. For rule selection, `rule` header should be used.
	// Since MetaDefender Core 5.6.0, when user agent is matched the predefined setting in workflow rule,  the product will return X-Core-Id containing identity of MetaDefender Core server as a header of response.
	//
	UserAgent *string `header:"style=simple,explode=false,name=user_agent"`
	// name of the selected workflow (deprecated, use "rule" header parameter instead)
	Workflow *string `header:"style=simple,explode=false,name=workflow"`
}

// FileAnalysisPost503ApplicationJSON - Server is too busy, scan queue is full. Try again later.
type FileAnalysisPost503ApplicationJSON struct {
	Err *string `json:"err,omitempty"`
}

// FileAnalysisPost500ApplicationJSON - Unexpected event on server
type FileAnalysisPost500ApplicationJSON struct {
	// Error reason
	Err *string `json:"err,omitempty"`
}

// FileAnalysisPost422ApplicationJSON - Body input is empty.
type FileAnalysisPost422ApplicationJSON struct {
	Err *string `json:"err,omitempty"`
}

// FileAnalysisPost411ApplicationJSON - Content-Length header is missing from the request.
type FileAnalysisPost411ApplicationJSON struct {
	Err *string `json:"err,omitempty"`
}

// FileAnalysisPost403ApplicationJSON - Invalid user information or Not Allowed
type FileAnalysisPost403ApplicationJSON struct {
	// Error reason
	Err *string `json:"err,omitempty"`
}

type FileAnalysisPost400ApplicationJSONType string

const (
	FileAnalysisPost400ApplicationJSONTypeBodyAndDownloadLinkGiven FileAnalysisPost400ApplicationJSONType = "BodyAndDownloadLinkGiven"
	FileAnalysisPost400ApplicationJSONTypeCallbackURLInvalid       FileAnalysisPost400ApplicationJSONType = "CallbackURLInvalid"
	FileAnalysisPost400ApplicationJSONTypeFileUploadRejected       FileAnalysisPost400ApplicationJSONType = "FileUploadRejected"
)

type FileAnalysisPost400ApplicationJSON struct {
	BodyAndDownloadLinkGiven *shared.BodyAndDownloadLinkGiven
	CallbackURLInvalid       *shared.CallbackURLInvalid
	FileUploadRejected       *shared.FileUploadRejected

	Type FileAnalysisPost400ApplicationJSONType
}

func CreateFileAnalysisPost400ApplicationJSONBodyAndDownloadLinkGiven(bodyAndDownloadLinkGiven shared.BodyAndDownloadLinkGiven) FileAnalysisPost400ApplicationJSON {
	typ := FileAnalysisPost400ApplicationJSONTypeBodyAndDownloadLinkGiven

	return FileAnalysisPost400ApplicationJSON{
		BodyAndDownloadLinkGiven: &bodyAndDownloadLinkGiven,
		Type:                     typ,
	}
}

func CreateFileAnalysisPost400ApplicationJSONCallbackURLInvalid(callbackURLInvalid shared.CallbackURLInvalid) FileAnalysisPost400ApplicationJSON {
	typ := FileAnalysisPost400ApplicationJSONTypeCallbackURLInvalid

	return FileAnalysisPost400ApplicationJSON{
		CallbackURLInvalid: &callbackURLInvalid,
		Type:               typ,
	}
}

func CreateFileAnalysisPost400ApplicationJSONFileUploadRejected(fileUploadRejected shared.FileUploadRejected) FileAnalysisPost400ApplicationJSON {
	typ := FileAnalysisPost400ApplicationJSONTypeFileUploadRejected

	return FileAnalysisPost400ApplicationJSON{
		FileUploadRejected: &fileUploadRejected,
		Type:               typ,
	}
}

func (u *FileAnalysisPost400ApplicationJSON) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	bodyAndDownloadLinkGiven := new(shared.BodyAndDownloadLinkGiven)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&bodyAndDownloadLinkGiven); err == nil {
		u.BodyAndDownloadLinkGiven = bodyAndDownloadLinkGiven
		u.Type = FileAnalysisPost400ApplicationJSONTypeBodyAndDownloadLinkGiven
		return nil
	}

	callbackURLInvalid := new(shared.CallbackURLInvalid)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&callbackURLInvalid); err == nil {
		u.CallbackURLInvalid = callbackURLInvalid
		u.Type = FileAnalysisPost400ApplicationJSONTypeCallbackURLInvalid
		return nil
	}

	fileUploadRejected := new(shared.FileUploadRejected)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&fileUploadRejected); err == nil {
		u.FileUploadRejected = fileUploadRejected
		u.Type = FileAnalysisPost400ApplicationJSONTypeFileUploadRejected
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u FileAnalysisPost400ApplicationJSON) MarshalJSON() ([]byte, error) {
	if u.BodyAndDownloadLinkGiven != nil {
		return json.Marshal(u.BodyAndDownloadLinkGiven)
	}

	if u.CallbackURLInvalid != nil {
		return json.Marshal(u.CallbackURLInvalid)
	}

	if u.FileUploadRejected != nil {
		return json.Marshal(u.FileUploadRejected)
	}

	return nil, nil
}

// FileAnalysisPost200ApplicationJSON - Successful file submission
type FileAnalysisPost200ApplicationJSON struct {
	// Unique submission identifier.
	// Use this value to reference the submission.
	//
	DataID string `json:"data_id"`
}

type FileAnalysisPostResponse struct {
	// HTTP response content type for this operation
	ContentType string
	Headers     map[string][]string
	// HTTP response status code for this operation
	StatusCode int
	// Raw HTTP response; suitable for custom response parsing
	RawResponse *http.Response
	// Successful file submission
	FileAnalysisPost200ApplicationJSONObject *FileAnalysisPost200ApplicationJSON
	// Callbackurl and/or apikey is invalid.
	FileAnalysisPost400ApplicationJSONOneOf *FileAnalysisPost400ApplicationJSON
	// Invalid user information or Not Allowed
	FileAnalysisPost403ApplicationJSONObject *FileAnalysisPost403ApplicationJSON
	// Content-Length header is missing from the request.
	FileAnalysisPost411ApplicationJSONObject *FileAnalysisPost411ApplicationJSON
	// Body input is empty.
	FileAnalysisPost422ApplicationJSONObject *FileAnalysisPost422ApplicationJSON
	// Unexpected event on server
	FileAnalysisPost500ApplicationJSONObject *FileAnalysisPost500ApplicationJSON
	// Server is too busy, scan queue is full. Try again later.
	FileAnalysisPost503ApplicationJSONObject *FileAnalysisPost503ApplicationJSON
}
